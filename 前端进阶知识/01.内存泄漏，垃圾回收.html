<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>内存泄漏，垃圾回收（GC）</title>
</head>
<body>
<script>
    /*
    * 垃圾回收（GC）？
    *
    * 早期浏览器使用引用计数，具体可以查阅一下相关示例，引用计数有一个问题就是当存在循环引用时，会引发问题
    *
    * 现在浏览器使用标记清除，具体可以查阅一下相关示例
    *
    * */

    /*
    * 前端如何检测内存变化以及内存泄漏？
    *
    * 使用浏览器调试工具的Performance Tab，具体可以查看一下示例
    *
    * */

    /*
    * 内存泄漏场景（以vue为例）
    *
    * 被全局变量、函数引用，组件销毁时未清除
    * 例如data中的数据，被使用window.xxx=this.xxx，通过这样的方式挂在到了window上并且最后没有卸载，就会有内存泄漏
    *
    * 被全局事件、定时器引用，组件销毁时未清除
    * 例如在vue组件中定义了全局事件，例如定义了addEventListener，回调中使用了data中的数据，这样就要在组件销毁时移除全局事件
    * 例如在定时器中使用了data的数据，这样就要在组件销毁时销毁定时器
    *
    * 被自定义事件引用，组件销毁时未清除
    * 例如在使用自定义事件进行组件之间传值的时候，需要在组件销毁的时候移除对自定义事件的监听
    *
    * */

    /*
    * 引申：闭包属于内存泄漏吗？
    * 这个问题可以说属于也可以说不属于，推荐一种回答，认为闭包不是内存泄漏，因为内存泄漏是预期之外的内存无法回收
    * 的情况，而闭包的内存无法回收是属于预期之内的
    * */
</script>
</body>
</html>